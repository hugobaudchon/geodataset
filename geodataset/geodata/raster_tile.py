import concurrent
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from typing import List

import numpy as np
import rasterio
from shapely import box
from shapely.geometry import box

from geodataset.utils import TileNameConvention, PolygonTileNameConvention


class RasterTile:
    """
    Class to represent a tile of a raster image. Generally generated by a :class:`~geodataset.geodata.raster.Raster`.

    Parameters
    ----------
    data: np.ndarray
        The pixel data of the tile (image).
    metadata: dict
        The metadata of the raster image. Should be compatible with rasterio.open(...) function.
        Examples of such metadata keys are 'crs', 'transform', 'width', 'height'...
    output_name: str
        The name of the output product. Usually the same as the Raster name.
        Used as the prefix for the final .tif file name when saving the tile.
    ground_resolution : float, optional
        The ground resolution in meter per pixel desired when loading the raster.
        Only one of ground_resolution and scale_factor can be set at the same time.
        Used for naming the .tif file when saving the tile.
    scale_factor : float, optional
        Scale factor for rescaling the data (change pixel resolution).
        Only one of ground_resolution and scale_factor can be set at the same time.
        Used for naming the .tif file when saving the tile
    row: int
        The row index of the tile in the raster (the top left pixel row).
        Used for naming the .tif file when saving the tile.
    col: int
        The column index of the tile in the raster (the top left pixel row).
        Used for naming the .tif file when saving the tile.
    """
    def __init__(self,
                 data: np.ndarray,
                 metadata: dict,
                 output_name: str,
                 ground_resolution: float,
                 scale_factor: float,
                 row: int,
                 col: int,
                 aoi: str = None,
                 tile_id: int = None):
        self.data = data
        self.metadata = metadata
        self.output_name = output_name
        self.row = row
        self.col = col
        self.aoi = aoi
        self.tile_id = tile_id

        assert not (ground_resolution and scale_factor), ("Both a ground_resolution and a scale_factor were provided."
                                                          " Please only specify one.")
        self.scale_factor = scale_factor
        self.ground_resolution = ground_resolution

    @classmethod
    def from_path(cls, path: str or Path):
        """
        Class method to load a tile from a .tif file.
        The .tif name should follow the naming convention of the :class:`~geodataset.utils.TileNameConvention`.

        Parameters
        ----------
        path: str or pathlib.Path
            The path to the .tif file.

        Returns
        -------
        RasterTile
            The loaded Tile.
        """

        path = Path(path)

        data, metadata, product_name, ground_resolution, scale_factor, row, col, aoi = RasterTile._load_tile(path)

        tile = cls(data=data,
                   metadata=metadata,
                   output_name=product_name,
                   ground_resolution=ground_resolution,
                   scale_factor=scale_factor,
                   row=row,
                   col=col,
                   aoi=aoi)

        return tile

    @staticmethod
    def _load_tile(path: Path):
        ext = path.suffix
        if ext != '.tif':
            raise Exception(f'The tile extension should be \'.tif\'.')

        with rasterio.open(path) as src:
            data = src.read()
            metadata = src.profile

        product_name, ground_resolution, scale_factor, row, col, aoi = TileNameConvention.parse_name(path.name)

        return data, metadata, product_name, ground_resolution, scale_factor, row, col, aoi

    def save(self, output_folder: str or Path):
        """
        Save the tile as a .tif file in the output_folder.

        Parameters
        ----------
        output_folder: str or pathlib.Path
            The path to the output folder where the tile should be saved.
        """

        output_folder = Path(output_folder)
        assert output_folder.exists(), f"The output folder {output_folder} doesn't exist yet."

        tile_name = self.generate_name()

        with rasterio.open(
                output_folder / tile_name,
                'w',
                **self.metadata) as tile_raster:
            tile_raster.write(self.data)

    def generate_name(self):
        """
        Generate the name of the tile based on its metadata.

        Returns
        -------
        str
            The name of the tile.
        """
        return TileNameConvention.create_name(product_name=self.output_name,
                                              ground_resolution=self.ground_resolution,
                                              scale_factor=self.scale_factor,
                                              row=self.row,
                                              col=self.col,
                                              aoi=self.aoi)

    def get_bbox(self):
        """
        Get the bounding box of the tile in its original Raster coordinates.

        Returns
        -------
        shapely.geometry.box
            The bounding box of the tile.
        """
        minx = self.col
        maxx = self.col + self.metadata['width']
        miny = self.row
        maxy = self.row + self.metadata['height']
        return box(minx, miny, maxx, maxy)

    def copy_with_aoi_and_id(self, new_aoi: str, new_id: int):
        """
        Create a copy of the tile with a new AOI.

        Parameters
        ----------
        new_aoi: str
            The new AOI to assign to the tile.
        new_id: int
            The new ID to assign to the tile.

        Returns
        -------
        RasterTile
            The new tile with the new AOI.
        """

        return RasterTile(data=self.data,
                          metadata=self.metadata,
                          output_name=self.output_name,
                          ground_resolution=self.ground_resolution,
                          scale_factor=self.scale_factor,
                          row=self.row,
                          col=self.col,
                          aoi=new_aoi,
                          tile_id=new_id)


class RasterPolygonTile:
    """
    Class to represent a single polygon label tile of a raster image. Generally generated by a :class:`~geodataset.geodata.raster.Raster`.

    Parameters
    ----------
    data: np.ndarray
        The pixel data of the tile (image).
    metadata: dict
        The metadata of the raster image. Should be compatible with rasterio.open(...) function.
        Examples of such metadata keys are 'crs', 'transform', 'width', 'height'...
    output_name: str
        The name of the output product. Usually the same as the Raster name.
        Used as the prefix for the final .tif file name when saving the tile.
    ground_resolution : float, optional
        The ground resolution in meter per pixel desired when loading the raster.
        Only one of ground_resolution and scale_factor can be set at the same time.
        Used for naming the .tif file when saving the tile.
    scale_factor : float, optional
        Scale factor for rescaling the data (change pixel resolution).
        Only one of ground_resolution and scale_factor can be set at the same time.
        Used for naming the .tif file when saving the tile.
    polygon_id: int
        The unique identifier of the polygon.
    """
    def __init__(self,
                 data: np.ndarray,
                 metadata: dict,
                 output_name: str,
                 ground_resolution: float,
                 scale_factor: float,
                 polygon_id: int,
                 aoi: str = None):

        self.data = data
        self.metadata = metadata
        self.output_name = output_name
        self.polygon_id = polygon_id
        self.aoi = aoi

        assert not (ground_resolution and scale_factor), ("Both a ground_resolution and a scale_factor were provided."
                                                          " Please only specify one.")
        self.scale_factor = scale_factor
        self.ground_resolution = ground_resolution

    @classmethod
    def from_path(cls, path: str or Path):
        """
        Class method to load a tile from a .tif file.
        The .tif name should follow the naming convention of the :class:`~geodataset.utils.PolygonTileNameConvention`.

        Parameters
        ----------
        path: str or pathlib.Path
            The path to the .tif file.

        Returns
        -------
        RasterPolygonTile
            The loaded PolygonTile.
        """

        path = Path(path)
        data, metadata, product_name, ground_resolution, scale_factor, polygon_id, aoi = RasterPolygonTile._load_tile(path)

        tile = cls(data=data,
                   metadata=metadata,
                   output_name=product_name,
                   ground_resolution=ground_resolution,
                   scale_factor=scale_factor,
                   polygon_id=polygon_id,
                   aoi=aoi)

        return tile

    @staticmethod
    def _load_tile(path: Path):
        ext = path.suffix
        if ext != '.tif':
            raise Exception(f'The tile extension should be \'.tif\'.')

        with rasterio.open(path) as src:
            data = src.read()
            metadata = src.profile

        product_name, ground_resolution, scale_factor, polygon_id, aoi = PolygonTileNameConvention.parse_name(path.name)

        return data, metadata, product_name, ground_resolution, scale_factor, polygon_id, aoi

    def save(self, output_folder: Path):
        """
        Save the tile as a .tif file in the output_folder.
        """
        assert output_folder.exists(), f"The output folder {output_folder} doesn't exist yet."

        tile_name = self.generate_name()

        with rasterio.open(
                output_folder / tile_name,
                'w',
                **self.metadata) as tile_raster:
            tile_raster.write(self.data)

    def generate_name(self):
        """
        Generate the name of the tile based on its metadata.

        Returns
        -------
        str
            The name of the tile.
        """
        return PolygonTileNameConvention.create_name(
            product_name=self.output_name,
            ground_resolution=self.ground_resolution,
            scale_factor=self.scale_factor,
            polygon_id=self.polygon_id,
            aoi=self.aoi
        )


class RasterTileSaver:
    """
    Class to save multiple tiles in parallel using ThreadPoolExecutor.

    Parameters
    ----------
    tiles_path: str or pathlib.Path
        The path to the folder where the tiles should be saved.
    n_workers: int
        The number of workers to use for saving the tiles.
    """
    def __init__(self, tiles_path: Path, n_workers: int):
        self.tiles_path = tiles_path
        self.n_workers = n_workers

    def save_tile(self, tile: RasterTile or RasterPolygonTile):
        """
        Save a single tile.

        Parameters
        ----------
        tile: RasterTile or RasterPolygonTile
            The tile to save.
        """
        try:
            tile.save(output_folder=self.tiles_path)
        except Exception as e:
            print(f"Error saving tile {tile.generate_name()}: {str(e)}")

    def save_all_tiles(self, tiles: List[RasterTile or RasterPolygonTile]):
        """
        Save all the tiles in parallel using ThreadPoolExecutor.

        Parameters
        ----------
        tiles: List[RasterTile or RasterPolygonTile]
            The list of tiles to save.
        """
        # Use ThreadPoolExecutor to manage threads
        with ThreadPoolExecutor(max_workers=self.n_workers) as executor:
            # Submit tasks to the executor
            futures = [executor.submit(self.save_tile, tile) for tile in tiles]

            # Optionally, you can wait for all futures to complete and handle exceptions
            for future in concurrent.futures.as_completed(futures):
                try:
                    future.result()  # If there was any exception it will be re-raised here
                except Exception as e:
                    print(f"An error occurred: {e}")


